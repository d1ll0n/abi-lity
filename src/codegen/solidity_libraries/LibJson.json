[
  "pragma solidity >=0.8.17;",
  "",
  "library LibJson {",
  "\tusing LibJson for *;",
  "  using LibStringStub for *;",
  "",
  "  using LibJson for address;",
  "  using LibJson for uint256;",
  "  using LibJson for uint256[];",
  "",
  "\t// StringLiteral internal constant Comma = StringLiteral.wrap(0x012c000000000000000000000000000000000000000000000000000000000000);",
  "\t// StringLiteral internal constant Colon = StringLiteral.wrap(0x013a000000000000000000000000000000000000000000000000000000000000);",
  "\t// StringLiteral internal constant Quote = StringLiteral.wrap(0x0122000000000000000000000000000000000000000000000000000000000000);",
  "",
  "\tfunction serializeArray(",
  "\t\tuint256[] memory arr,",
  "\t\tfunction(uint256 /* element */) pure returns (string memory) serializeElement",
  "\t) internal pure returns (string memory output) {",
  "\t\toutput = '[';",
  "\t\tuint256 lastIndex = arr.length - 1;",
  "\t\tfor (uint256 i = 0; i < lastIndex; i++) {",
  "\t\t\toutput = string.concat(output, serializeElement(arr[i]), ',');",
  "\t\t}",
  "\t\toutput = string.concat(output, serializeElement(arr[lastIndex]), ']');",
  "\t}",
  "",
  "\tfunction serializeObject(",
  "\t\tstring[] memory keys,",
  "\t\tstring[] memory values",
  "\t) internal pure returns (string memory output) {",
  "\t\toutput = '{';",
  "\t\tuint256 lastIndex = keys.length - 1;",
  "\t\tfor (uint256 i = 0; i < lastIndex; i++) {",
  "\t\t\toutput = string.concat(output, '\"', keys[i], '\": ', values[i], ',');",
  "\t\t}",
  "\t\toutput = string.concat(output, '\"', keys[lastIndex], '\":', values[lastIndex], '}');",
  "\t}",
  "",
  "\tfunction serializeUint256(uint256 value) internal pure returns (string memory) {",
  "\t\t// Max safe number in JS",
  "\t\tif (value > 9007199254740991) {",
  "\t\t\treturn value.toHexString().serializeString();",
  "\t\t}",
  "\t\treturn value.toString();",
  "\t}",
  "",
  "\tfunction serializeInt256(int256 value) internal pure returns (string memory) {",
  "\t\t// Min/max safe numbers in JS",
  "\t\tif (value > 9007199254740991 || value < -9007199254740991) {",
  "\t\t\treturn value.toHexString().serializeString();",
  "\t\t}",
  "\t\treturn value.toString();",
  "\t}",
  "",
  "\tfunction serializeBytes32(bytes32 value) internal pure returns (string memory) {",
  "\t\treturn uint256(value).toHexString().serializeString();",
  "\t}",
  "",
  "\tfunction serializeBytes(bytes memory value) internal pure returns (string memory) {",
  "\t\treturn value.toHexString().serializeString();",
  "\t}",
  "",
  "\tfunction serializeString(string memory value) internal pure returns (string memory) {",
  "\t\treturn string.concat('\"', value, '\"');",
  "\t}",
  "",
  "\tfunction serializeBool(bool value) internal pure returns (string memory) {",
  "\t\treturn value ? 'true' : 'false';",
  "\t}",
  "",
  "\tfunction serializeAddress(address value) internal pure returns (string memory) {",
  "\t\treturn value.toHexString().serializeString();",
  "\t}",
  "",
  "\tfunction toHexString(int256 value) internal pure returns (string memory str) {",
  "\t\tif (value >= 0) {",
  "\t\t\treturn uint256(value).toHexString();",
  "\t\t}",
  "\t\tunchecked {",
  "\t\t\tstr = uint256(-value).toHexString();",
  "\t\t}",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// We still have some spare memory space on the left,",
  "\t\t\t// as we have allocated 3 words (96 bytes) for up to 78 digits.",
  "\t\t\tlet length := mload(str) // Load the string length.",
  "\t\t\tmstore(str, 0x2d) // Store the '-' character.",
  "\t\t\tstr := sub(str, 1) // Move back the string pointer by a byte.",
  "\t\t\tmstore(str, add(length, 1)) // Update the string length.",
  "\t\t}",
  "\t}",
  "",
  "\tfunction serializeBoolArray(bool[] memory arr) internal pure returns (string memory) {",
  "\t\tfunction(uint256[] memory, function(uint256) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) _fn = serializeArray;",
  "\t\tfunction(bool[] memory, function(bool) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) fn;",
  "\t\tassembly {",
  "\t\t\tfn := _fn",
  "\t\t}",
  "\t\treturn fn(arr, serializeBool);",
  "\t}",
  "",
  "\tfunction serializeUint256Array(uint256[] memory arr) internal pure returns (string memory) {",
  "\t\treturn serializeArray(arr, serializeUint256);",
  "\t}",
  "",
  "\tfunction serializeInt256Array(int256[] memory arr) internal pure returns (string memory) {",
  "\t\tfunction(uint256[] memory, function(uint256) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) _fn = serializeArray;",
  "\t\tfunction(int256[] memory, function(int256) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) fn;",
  "\t\tassembly {",
  "\t\t\tfn := _fn",
  "\t\t}",
  "\t\treturn fn(arr, serializeInt256);",
  "\t}",
  "",
  "\tfunction serializeAddressArray(address[] memory arr) internal pure returns (string memory) {",
  "\t\tfunction(uint256[] memory, function(uint256) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) _fn = serializeArray;",
  "\t\tfunction(address[] memory, function(address) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) fn;",
  "\t\tassembly {",
  "\t\t\tfn := _fn",
  "\t\t}",
  "\t\treturn fn(arr, serializeAddress);",
  "\t}",
  "",
  "\tfunction serializeBytes32Array(bytes32[] memory arr) internal pure returns (string memory) {",
  "\t\tfunction(uint256[] memory, function(uint256) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) _fn = serializeArray;",
  "\t\tfunction(bytes32[] memory, function(bytes32) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) fn;",
  "\t\tassembly {",
  "\t\t\tfn := _fn",
  "\t\t}",
  "\t\treturn fn(arr, serializeBytes32);",
  "\t}",
  "",
  "\tfunction serializeStringArray(string[] memory arr) internal pure returns (string memory) {",
  "\t\tfunction(uint256[] memory, function(uint256) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) _fn = serializeArray;",
  "\t\tfunction(string[] memory, function(string memory) pure returns (string memory))",
  "\t\t\tinternal",
  "\t\t\tpure",
  "\t\t\treturns (string memory) fn;",
  "\t\tassembly {",
  "\t\t\tfn := _fn",
  "\t\t}",
  "\t\treturn fn(arr, serializeString);",
  "\t}",
  "}",
  "",
  "library LibStringStub {",
  "\t/// @dev Returns the base 10 decimal representation of `value`.",
  "\tfunction toString(uint256 value) internal pure returns (string memory str) {",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// The maximum value of a uint256 contains 78 digits (1 byte per digit), but",
  "\t\t\t// we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.",
  "\t\t\t// We will need 1 word for the trailing zeros padding, 1 word for the length,",
  "\t\t\t// and 3 words for a maximum of 78 digits.",
  "\t\t\tstr := add(mload(0x40), 0x80)",
  "\t\t\t// Update the free memory pointer to allocate.",
  "\t\t\tmstore(0x40, add(str, 0x20))",
  "\t\t\t// Zeroize the slot after the string.",
  "\t\t\tmstore(str, 0)",
  "",
  "\t\t\t// Cache the end of the memory to calculate the length later.",
  "\t\t\tlet end := str",
  "",
  "\t\t\tlet w := not(0) // Tsk.",
  "\t\t\t// We write the string from rightmost digit to leftmost digit.",
  "\t\t\t// The following is essentially a do-while loop that also handles the zero case.",
  "\t\t\tfor {",
  "\t\t\t\tlet temp := value",
  "\t\t\t} 1 {",
  "",
  "\t\t\t} {",
  "\t\t\t\tstr := add(str, w) // `sub(str, 1)`.",
  "\t\t\t\t// Write the character to the pointer.",
  "\t\t\t\t// The ASCII index of the '0' character is 48.",
  "\t\t\t\tmstore8(str, add(48, mod(temp, 10)))",
  "\t\t\t\t// Keep dividing `temp` until zero.",
  "\t\t\t\ttemp := div(temp, 10)",
  "\t\t\t\tif iszero(temp) {",
  "\t\t\t\t\tbreak",
  "\t\t\t\t}",
  "\t\t\t}",
  "",
  "\t\t\tlet length := sub(end, str)",
  "\t\t\t// Move the pointer 32 bytes leftwards to make room for the length.",
  "\t\t\tstr := sub(str, 0x20)",
  "\t\t\t// Store the length.",
  "\t\t\tmstore(str, length)",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the base 10 decimal representation of `value`.",
  "\tfunction toString(int256 value) internal pure returns (string memory str) {",
  "\t\tif (value >= 0) {",
  "\t\t\treturn toString(uint256(value));",
  "\t\t}",
  "\t\tunchecked {",
  "\t\t\tstr = toString(uint256(-value));",
  "\t\t}",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// We still have some spare memory space on the left,",
  "\t\t\t// as we have allocated 3 words (96 bytes) for up to 78 digits.",
  "\t\t\tlet length := mload(str) // Load the string length.",
  "\t\t\tmstore(str, 0x2d) // Store the '-' character.",
  "\t\t\tstr := sub(str, 1) // Move back the string pointer by a byte.",
  "\t\t\tmstore(str, add(length, 1)) // Update the string length.",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.",
  "\t/// As address are 20 bytes long, the output will left-padded to have",
  "\t/// a length of `20 * 2 + 2` bytes.",
  "\tfunction toHexString(uint256 value) internal pure returns (string memory str) {",
  "\t\tstr = toHexStringNoPrefix(value);",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tlet strLength := add(mload(str), 2) // Compute the length.",
  "\t\t\tmstore(str, 0x3078) // Write the \"0x\" prefix.",
  "\t\t\tstr := sub(str, 2) // Move the pointer.",
  "\t\t\tmstore(str, strLength) // Write the length.",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is encoded using 2 hexadecimal digits per byte.",
  "\t/// As address are 20 bytes long, the output will left-padded to have",
  "\t/// a length of `20 * 2` bytes.",
  "\tfunction toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,",
  "\t\t\t// 0x02 bytes for the prefix, and 0x40 bytes for the digits.",
  "\t\t\t// The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.",
  "\t\t\tstr := add(mload(0x40), 0x80)",
  "\t\t\t// Allocate the memory.",
  "\t\t\tmstore(0x40, add(str, 0x20))",
  "\t\t\t// Zeroize the slot after the string.",
  "\t\t\tmstore(str, 0)",
  "",
  "\t\t\t// Cache the end to calculate the length later.",
  "\t\t\tlet end := str",
  "\t\t\t// Store \"0123456789abcdef\" in scratch space.",
  "\t\t\tmstore(0x0f, 0x30313233343536373839616263646566)",
  "",
  "\t\t\tlet w := not(1) // Tsk.",
  "\t\t\t// We write the string from rightmost digit to leftmost digit.",
  "\t\t\t// The following is essentially a do-while loop that also handles the zero case.",
  "\t\t\tfor {",
  "\t\t\t\tlet temp := value",
  "\t\t\t} 1 {",
  "",
  "\t\t\t} {",
  "\t\t\t\tstr := add(str, w) // `sub(str, 2)`.",
  "\t\t\t\tmstore8(add(str, 1), mload(and(temp, 15)))",
  "\t\t\t\tmstore8(str, mload(and(shr(4, temp), 15)))",
  "\t\t\t\ttemp := shr(8, temp)",
  "\t\t\t\tif iszero(temp) {",
  "\t\t\t\t\tbreak",
  "\t\t\t\t}",
  "\t\t\t}",
  "",
  "\t\t\t// Compute the string's length.",
  "\t\t\tlet strLength := sub(end, str)",
  "\t\t\t// Move the pointer and write the length.",
  "\t\t\tstr := sub(str, 0x20)",
  "\t\t\tmstore(str, strLength)",
  "\t\t}",
  "\t}",
  "",
  "  /// @dev Returns the hexadecimal representation of `value`.",
  "  /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.",
  "  function toHexString(address value) internal pure returns (string memory str) {",
  "      str = toHexStringNoPrefix(value);",
  "      /// @solidity memory-safe-assembly",
  "      assembly {",
  "          let strLength := add(mload(str), 2) // Compute the length.",
  "          mstore(str, 0x3078) // Write the \"0x\" prefix.",
  "          str := sub(str, 2) // Move the pointer.",
  "          mstore(str, strLength) // Write the length.",
  "      }",
  "  }",
  "",
  "  /// @dev Returns the hexadecimal representation of `value`.",
  "  /// The output is encoded using 2 hexadecimal digits per byte.",
  "  function toHexStringNoPrefix(address value) internal pure returns (string memory str) {",
  "      /// @solidity memory-safe-assembly",
  "      assembly {",
  "          str := mload(0x40)",
  "",
  "          // Allocate the memory.",
  "          // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,",
  "          // 0x02 bytes for the prefix, and 0x28 bytes for the digits.",
  "          // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.",
  "          mstore(0x40, add(str, 0x80))",
  "",
  "          // Store \"0123456789abcdef\" in scratch space.",
  "          mstore(0x0f, 0x30313233343536373839616263646566)",
  "",
  "          str := add(str, 2)",
  "          mstore(str, 40)",
  "",
  "          let o := add(str, 0x20)",
  "          mstore(add(o, 40), 0)",
  "",
  "          value := shl(96, value)",
  "",
  "          // We write the string from rightmost digit to leftmost digit.",
  "          // The following is essentially a do-while loop that also handles the zero case.",
  "          for { let i := 0 } 1 {} {",
  "              let p := add(o, add(i, i))",
  "              let temp := byte(i, value)",
  "              mstore8(add(p, 1), mload(and(temp, 15)))",
  "              mstore8(p, mload(shr(4, temp)))",
  "              i := add(i, 1)",
  "              if eq(i, 20) { break }",
  "          }",
  "      }",
  "  }",
  "",
  "  /// @dev Returns the hex encoded string from the raw bytes.",
  "  /// The output is encoded using 2 hexadecimal digits per byte.",
  "  function toHexString(bytes memory raw) internal pure returns (string memory str) {",
  "      str = toHexStringNoPrefix(raw);",
  "      /// @solidity memory-safe-assembly",
  "      assembly {",
  "          let strLength := add(mload(str), 2) // Compute the length.",
  "          mstore(str, 0x3078) // Write the \"0x\" prefix.",
  "          str := sub(str, 2) // Move the pointer.",
  "          mstore(str, strLength) // Write the length.",
  "      }",
  "  }",
  "",
  "  /// @dev Returns the hex encoded string from the raw bytes.",
  "  /// The output is encoded using 2 hexadecimal digits per byte.",
  "  function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {",
  "      /// @solidity memory-safe-assembly",
  "      assembly {",
  "          let length := mload(raw)",
  "          str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.",
  "          mstore(str, add(length, length)) // Store the length of the output.",
  "",
  "          // Store \"0123456789abcdef\" in scratch space.",
  "          mstore(0x0f, 0x30313233343536373839616263646566)",
  "",
  "          let o := add(str, 0x20)",
  "          let end := add(raw, length)",
  "",
  "          for {} iszero(eq(raw, end)) {} {",
  "              raw := add(raw, 1)",
  "              mstore8(add(o, 1), mload(and(mload(raw), 15)))",
  "              mstore8(o, mload(and(shr(4, mload(raw)), 15)))",
  "              o := add(o, 2)",
  "          }",
  "          mstore(o, 0) // Zeroize the slot after the string.",
  "          mstore(0x40, and(add(o, 31), not(31))) // Allocate the memory.",
  "      }",
  "  }",
  "}",
  ""
]
