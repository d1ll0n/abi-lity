[
  "// SPDX-License-Identifier: MIT",
  "pragma solidity >=0.8.17;",
  "",
  "library JsonLib {",
  "\tusing LibStringPartial for *;",
  "\tusing JsonLib for *;",
  "",
  "\tfunction serializeObject(",
  "\t\tstring[] memory keys,",
  "\t\tstring[] memory values",
  "\t) internal pure returns (string memory output) {",
  "\t\toutput = '{';",
  "\t\tuint256 lastIndex = keys.length - 1;",
  "\t\tfor (uint256 i = 0; i < lastIndex; i++) {",
  "\t\t\tserializeKeyValuePair(keys[i], values[i], false);",
  "\t\t}",
  "\t\toutput = string.concat(output, '\"', keys[lastIndex], '\":', values[lastIndex], '}');",
  "\t}",
  "",
  "\tfunction serializeKeyValuePair(",
  "\t\tstring memory key,",
  "\t\tstring memory value,",
  "\t\tbool isLast",
  "\t) internal pure returns (string memory output) {",
  "\t\toutput = string.concat('\"', key, '\":', value);",
  "\t\tif (!isLast) {",
  "\t\t\toutput = string.concat(output, ',');",
  "\t\t}",
  "\t}",
  "",
  "\tfunction serializeUint(uint256 value) internal pure returns (string memory) {",
  "\t\t// Max safe number in JavaScript is 2^53 - 1.",
  "    // Above this number, output hex string.",
  "\t\tif (value > 9007199254740991) {",
  "\t\t\treturn value.toHexString().serializeString();",
  "\t\t}",
  "\t\treturn value.toString();",
  "\t}",
  "",
  "\tfunction serializeInt(int256 value) internal pure returns (string memory) {",
  "\t\t// Max safe number in JavaScript is 2^53 - 1.",
  "    // Min safe number in JavaScript is -(2^53 - 1).",
  "    // Outside of these bounds, output hex string.",
  "\t\tif (value > 9007199254740991 || value < -9007199254740991) {",
  "\t\t\treturn value.toHexString().serializeString();",
  "\t\t}",
  "\t\treturn value.toString();",
  "\t}",
  "",
  "\tfunction serializeBytes32(bytes32 value) internal pure returns (string memory) {",
  "\t\treturn uint256(value).toHexString();",
  "\t}",
  "",
  "\tfunction serializeBytes(bytes memory value) internal pure returns (string memory) {",
  "\t\treturn value.toHexString().serializeString();",
  "\t}",
  "",
  "\tfunction serializeString(string memory value) internal pure returns (string memory) {",
  "\t\treturn string.concat('\"', value, '\"');",
  "\t}",
  "",
  "\tfunction serializeBool(bool value) internal pure returns (string memory) {",
  "\t\treturn value ? 'true' : 'false';",
  "\t}",
  "",
  "\tfunction serializeAddress(address value) internal pure returns (string memory) {",
  "\t\treturn value.toHexStringChecksumed().serializeString();",
  "\t}",
  "}",
  "",
  "/// @custom:author Vectorized",
  "/// Partial copy of solady/src/utils/LibString.sol",
  "library LibStringPartial {",
  "\t/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/",
  "\t/*                        CUSTOM ERRORS                       */",
  "\t/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/",
  "",
  "\t/// @dev The `length` of the output is too small to contain all the hex digits.",
  "\terror HexLengthInsufficient();",
  "",
  "\t/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/",
  "\t/*                     DECIMAL OPERATIONS                     */",
  "\t/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/",
  "",
  "\t/// @dev Returns the base 10 decimal representation of `value`.",
  "\tfunction toString(uint256 value) internal pure returns (string memory str) {",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// The maximum value of a uint256 contains 78 digits (1 byte per digit), but",
  "\t\t\t// we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.",
  "\t\t\t// We will need 1 word for the trailing zeros padding, 1 word for the length,",
  "\t\t\t// and 3 words for a maximum of 78 digits.",
  "\t\t\tstr := add(mload(0x40), 0x80)",
  "\t\t\t// Update the free memory pointer to allocate.",
  "\t\t\tmstore(0x40, add(str, 0x20))",
  "\t\t\t// Zeroize the slot after the string.",
  "\t\t\tmstore(str, 0)",
  "",
  "\t\t\t// Cache the end of the memory to calculate the length later.",
  "\t\t\tlet end := str",
  "",
  "\t\t\tlet w := not(0) // Tsk.",
  "\t\t\t// We write the string from rightmost digit to leftmost digit.",
  "\t\t\t// The following is essentially a do-while loop that also handles the zero case.",
  "\t\t\tfor {",
  "\t\t\t\tlet temp := value",
  "\t\t\t} 1 {",
  "",
  "\t\t\t} {",
  "\t\t\t\tstr := add(str, w) // `sub(str, 1)`.",
  "\t\t\t\t// Write the character to the pointer.",
  "\t\t\t\t// The ASCII index of the '0' character is 48.",
  "\t\t\t\tmstore8(str, add(48, mod(temp, 10)))",
  "\t\t\t\t// Keep dividing `temp` until zero.",
  "\t\t\t\ttemp := div(temp, 10)",
  "\t\t\t\tif iszero(temp) {",
  "\t\t\t\t\tbreak",
  "\t\t\t\t}",
  "\t\t\t}",
  "",
  "\t\t\tlet length := sub(end, str)",
  "\t\t\t// Move the pointer 32 bytes leftwards to make room for the length.",
  "\t\t\tstr := sub(str, 0x20)",
  "\t\t\t// Store the length.",
  "\t\t\tmstore(str, length)",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the base 10 decimal representation of `value`.",
  "\tfunction toString(int256 value) internal pure returns (string memory str) {",
  "\t\tif (value >= 0) {",
  "\t\t\treturn toString(uint256(value));",
  "\t\t}",
  "\t\tunchecked {",
  "\t\t\tstr = toString(uint256(-value));",
  "\t\t}",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// We still have some spare memory space on the left,",
  "\t\t\t// as we have allocated 3 words (96 bytes) for up to 78 digits.",
  "\t\t\tlet length := mload(str) // Load the string length.",
  "\t\t\tmstore(str, 0x2d) // Store the '-' character.",
  "\t\t\tstr := sub(str, 1) // Move back the string pointer by a byte.",
  "\t\t\tmstore(str, add(length, 1)) // Update the string length.",
  "\t\t}",
  "\t}",
  "",
  "\t/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/",
  "\t/*                   HEXADECIMAL OPERATIONS                   */",
  "\t/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`,",
  "\t/// left-padded to an input length of `length` bytes.",
  "\t/// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,",
  "\t/// giving a total length of `length * 2 + 2` bytes.",
  "\t/// Reverts if `length` is too small for the output to contain all the digits.",
  "\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {",
  "\t\tstr = toHexStringNoPrefix(value, length);",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tlet strLength := add(mload(str), 2) // Compute the length.",
  "\t\t\tmstore(str, 0x3078) // Write the \"0x\" prefix.",
  "\t\t\tstr := sub(str, 2) // Move the pointer.",
  "\t\t\tmstore(str, strLength) // Write the length.",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`,",
  "\t/// left-padded to an input length of `length` bytes.",
  "\t/// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,",
  "\t/// giving a total length of `length * 2` bytes.",
  "\t/// Reverts if `length` is too small for the output to contain all the digits.",
  "\tfunction toHexStringNoPrefix(",
  "\t\tuint256 value,",
  "\t\tuint256 length",
  "\t) internal pure returns (string memory str) {",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes",
  "\t\t\t// for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.",
  "\t\t\t// We add 0x20 to the total and round down to a multiple of 0x20.",
  "\t\t\t// (0x20 + 0x20 + 0x02 + 0x20) = 0x62.",
  "\t\t\tstr := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))",
  "\t\t\t// Allocate the memory.",
  "\t\t\tmstore(0x40, add(str, 0x20))",
  "\t\t\t// Zeroize the slot after the string.",
  "\t\t\tmstore(str, 0)",
  "",
  "\t\t\t// Cache the end to calculate the length later.",
  "\t\t\tlet end := str",
  "\t\t\t// Store \"0123456789abcdef\" in scratch space.",
  "\t\t\tmstore(0x0f, 0x30313233343536373839616263646566)",
  "",
  "\t\t\tlet start := sub(str, add(length, length))",
  "\t\t\tlet w := not(1) // Tsk.",
  "\t\t\tlet temp := value",
  "\t\t\t// We write the string from rightmost digit to leftmost digit.",
  "\t\t\t// The following is essentially a do-while loop that also handles the zero case.",
  "\t\t\tfor {",
  "",
  "\t\t\t} 1 {",
  "",
  "\t\t\t} {",
  "\t\t\t\tstr := add(str, w) // `sub(str, 2)`.",
  "\t\t\t\tmstore8(add(str, 1), mload(and(temp, 15)))",
  "\t\t\t\tmstore8(str, mload(and(shr(4, temp), 15)))",
  "\t\t\t\ttemp := shr(8, temp)",
  "\t\t\t\tif iszero(xor(str, start)) {",
  "\t\t\t\t\tbreak",
  "\t\t\t\t}",
  "\t\t\t}",
  "",
  "\t\t\tif temp {",
  "\t\t\t\t// Store the function selector of `HexLengthInsufficient()`.",
  "\t\t\t\tmstore(0x00, 0x2194895a)",
  "\t\t\t\t// Revert with (offset, size).",
  "\t\t\t\trevert(0x1c, 0x04)",
  "\t\t\t}",
  "",
  "\t\t\t// Compute the string's length.",
  "\t\t\tlet strLength := sub(end, str)",
  "\t\t\t// Move the pointer and write the length.",
  "\t\t\tstr := sub(str, 0x20)",
  "\t\t\tmstore(str, strLength)",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.",
  "\tfunction toHexString(uint256 value) internal pure returns (string memory str) {",
  "\t\tstr = toHexStringNoPrefix(value);",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tlet strLength := add(mload(str), 2) // Compute the length.",
  "\t\t\tmstore(str, 0x3078) // Write the \"0x\" prefix.",
  "\t\t\tstr := sub(str, 2) // Move the pointer.",
  "\t\t\tmstore(str, strLength) // Write the length.",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is encoded using 2 hexadecimal digits per byte.",
  "\tfunction toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,",
  "\t\t\t// 0x02 bytes for the prefix, and 0x40 bytes for the digits.",
  "\t\t\t// The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.",
  "\t\t\tstr := add(mload(0x40), 0x80)",
  "\t\t\t// Allocate the memory.",
  "\t\t\tmstore(0x40, add(str, 0x20))",
  "\t\t\t// Zeroize the slot after the string.",
  "\t\t\tmstore(str, 0)",
  "",
  "\t\t\t// Cache the end to calculate the length later.",
  "\t\t\tlet end := str",
  "\t\t\t// Store \"0123456789abcdef\" in scratch space.",
  "\t\t\tmstore(0x0f, 0x30313233343536373839616263646566)",
  "",
  "\t\t\tlet w := not(1) // Tsk.",
  "\t\t\t// We write the string from rightmost digit to leftmost digit.",
  "\t\t\t// The following is essentially a do-while loop that also handles the zero case.",
  "\t\t\tfor {",
  "\t\t\t\tlet temp := value",
  "\t\t\t} 1 {",
  "",
  "\t\t\t} {",
  "\t\t\t\tstr := add(str, w) // `sub(str, 2)`.",
  "\t\t\t\tmstore8(add(str, 1), mload(and(temp, 15)))",
  "\t\t\t\tmstore8(str, mload(and(shr(4, temp), 15)))",
  "\t\t\t\ttemp := shr(8, temp)",
  "\t\t\t\tif iszero(temp) {",
  "\t\t\t\t\tbreak",
  "\t\t\t\t}",
  "\t\t\t}",
  "",
  "\t\t\t// Compute the string's length.",
  "\t\t\tlet strLength := sub(end, str)",
  "\t\t\t// Move the pointer and write the length.",
  "\t\t\tstr := sub(str, 0x20)",
  "\t\t\tmstore(str, strLength)",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.",
  "\t/// If `value` is negative, the output is additionally prefixed with \"-\".",
  "\tfunction toHexString(int256 value) internal pure returns (string memory str) {",
  "\t\tif (value >= 0) {",
  "\t\t\treturn toHexString(uint256(value));",
  "\t\t}",
  "\t\tunchecked {",
  "\t\t\tstr = toHexString(uint256(-value));",
  "\t\t}",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\t// We still have some spare memory space on the left,",
  "\t\t\t// as we have allocated 3 words (96 bytes) for up to 78 digits.",
  "\t\t\tlet length := mload(str) // Load the string length.",
  "\t\t\tmstore(str, 0x2d) // Store the '-' character.",
  "\t\t\tstr := sub(str, 1) // Move back the string pointer by a byte.",
  "\t\t\tmstore(str, add(length, 1)) // Update the string length.",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,",
  "\t/// and the alphabets are capitalized conditionally according to",
  "\t/// https://eips.ethereum.org/EIPS/eip-55",
  "\tfunction toHexStringChecksumed(address value) internal pure returns (string memory str) {",
  "\t\tstr = toHexString(value);",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tlet mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`",
  "\t\t\tlet o := add(str, 0x22)",
  "\t\t\tlet hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `",
  "\t\t\tlet t := shl(240, 136) // `0b10001000 << 240`",
  "\t\t\tfor {",
  "\t\t\t\tlet i := 0",
  "\t\t\t} 1 {",
  "",
  "\t\t\t} {",
  "\t\t\t\tmstore(add(i, i), mul(t, byte(i, hashed)))",
  "\t\t\t\ti := add(i, 1)",
  "\t\t\t\tif eq(i, 20) {",
  "\t\t\t\t\tbreak",
  "\t\t\t\t}",
  "\t\t\t}",
  "\t\t\tmstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))",
  "\t\t\to := add(o, 0x20)",
  "\t\t\tmstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.",
  "\tfunction toHexString(address value) internal pure returns (string memory str) {",
  "\t\tstr = toHexStringNoPrefix(value);",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tlet strLength := add(mload(str), 2) // Compute the length.",
  "\t\t\tmstore(str, 0x3078) // Write the \"0x\" prefix.",
  "\t\t\tstr := sub(str, 2) // Move the pointer.",
  "\t\t\tmstore(str, strLength) // Write the length.",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hexadecimal representation of `value`.",
  "\t/// The output is encoded using 2 hexadecimal digits per byte.",
  "\tfunction toHexStringNoPrefix(address value) internal pure returns (string memory str) {",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tstr := mload(0x40)",
  "",
  "\t\t\t// Allocate the memory.",
  "\t\t\t// We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,",
  "\t\t\t// 0x02 bytes for the prefix, and 0x28 bytes for the digits.",
  "\t\t\t// The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.",
  "\t\t\tmstore(0x40, add(str, 0x80))",
  "",
  "\t\t\t// Store \"0123456789abcdef\" in scratch space.",
  "\t\t\tmstore(0x0f, 0x30313233343536373839616263646566)",
  "",
  "\t\t\tstr := add(str, 2)",
  "\t\t\tmstore(str, 40)",
  "",
  "\t\t\tlet o := add(str, 0x20)",
  "\t\t\tmstore(add(o, 40), 0)",
  "",
  "\t\t\tvalue := shl(96, value)",
  "",
  "\t\t\t// We write the string from rightmost digit to leftmost digit.",
  "\t\t\t// The following is essentially a do-while loop that also handles the zero case.",
  "\t\t\tfor {",
  "\t\t\t\tlet i := 0",
  "\t\t\t} 1 {",
  "",
  "\t\t\t} {",
  "\t\t\t\tlet p := add(o, add(i, i))",
  "\t\t\t\tlet temp := byte(i, value)",
  "\t\t\t\tmstore8(add(p, 1), mload(and(temp, 15)))",
  "\t\t\t\tmstore8(p, mload(shr(4, temp)))",
  "\t\t\t\ti := add(i, 1)",
  "\t\t\t\tif eq(i, 20) {",
  "\t\t\t\t\tbreak",
  "\t\t\t\t}",
  "\t\t\t}",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hex encoded string from the raw bytes.",
  "\t/// The output is encoded using 2 hexadecimal digits per byte.",
  "\tfunction toHexString(bytes memory raw) internal pure returns (string memory str) {",
  "\t\tstr = toHexStringNoPrefix(raw);",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tlet strLength := add(mload(str), 2) // Compute the length.",
  "\t\t\tmstore(str, 0x3078) // Write the \"0x\" prefix.",
  "\t\t\tstr := sub(str, 2) // Move the pointer.",
  "\t\t\tmstore(str, strLength) // Write the length.",
  "\t\t}",
  "\t}",
  "",
  "\t/// @dev Returns the hex encoded string from the raw bytes.",
  "\t/// The output is encoded using 2 hexadecimal digits per byte.",
  "\tfunction toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {",
  "\t\t/// @solidity memory-safe-assembly",
  "\t\tassembly {",
  "\t\t\tlet length := mload(raw)",
  "\t\t\tstr := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.",
  "\t\t\tmstore(str, add(length, length)) // Store the length of the output.",
  "",
  "\t\t\t// Store \"0123456789abcdef\" in scratch space.",
  "\t\t\tmstore(0x0f, 0x30313233343536373839616263646566)",
  "",
  "\t\t\tlet o := add(str, 0x20)",
  "\t\t\tlet end := add(raw, length)",
  "",
  "\t\t\tfor {",
  "",
  "\t\t\t} iszero(eq(raw, end)) {",
  "",
  "\t\t\t} {",
  "\t\t\t\traw := add(raw, 1)",
  "\t\t\t\tmstore8(add(o, 1), mload(and(mload(raw), 15)))",
  "\t\t\t\tmstore8(o, mload(and(shr(4, mload(raw)), 15)))",
  "\t\t\t\to := add(o, 2)",
  "\t\t\t}",
  "\t\t\tmstore(o, 0) // Zeroize the slot after the string.",
  "\t\t\tmstore(0x40, and(add(o, 31), not(31))) // Allocate the memory.",
  "\t\t}",
  "\t}",
  "}",
  ""
]