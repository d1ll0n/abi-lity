import { writeFileSync } from "fs";
import path from "path";
import yargs, { Argv } from "yargs";
import { cleanIR, findExternalYulFunction, findYulFunction } from "../../../codegen/utils";
import {
  CompileHelper,
  coerceArray,
  getRelativePath,
  isExternalFunction,
  mkdirIfNotExists,
  writeNestedStructure
} from "../../../utils";
import { getCommandLineInputPaths, printCodeSize } from "../../utils2";
import {
  ASTNode,
  ASTReader,
  ASTSearch,
  ASTWriter,
  CompilationOutput,
  ContractDefinition,
  DefaultASTWriterMapping,
  FunctionDefinition,
  LatestCompilerVersion,
  PrettyFormatter,
  SourceUnit,
  YulFunctionDefinition,
  YulObject
} from "solc-typed-ast";
import { err, info, success, warn } from "../../../test_utils/logs";
import { ModernConfiguration } from "solc-typed-ast/dist/ast/modern";
import { parseYulIdentifier } from "../../../analysis/ir_tracker/yul-id-regex";
import { highlightYul } from "./hljs";

type Opts<O> = O extends { [key: string]: yargs.Options } ? O : never;

const toOptions = <O extends { [key: string]: yargs.Options }>(o: O): O => o;

const options = toOptions({
  input: {
    alias: ["i"],
    describe: "Input Solidity file.",
    demandOption: true,
    coerce: path.resolve
  },
  output: {
    alias: ["o"],
    describe: "Output directory, defaults to directory of input.",
    demandOption: false,
    coerce: path.resolve
  },
  ir: {
    describe: "Include the unoptimized ir output.",
    default: false,
    type: "boolean"
  },
  ["no-constructor"]: {
    alias: ["nc"],
    describe: "Exclude the constructor from the IR output.",
    default: false,
    type: "boolean"
  },
  ["no-sourcemap"]: {
    alias: ["ns"],
    describe: "Exclude the sourcemap comments from the IR output.",
    default: false,
    type: "boolean"
  },
  runs: {
    alias: ["r"],
    default: 200,
    describe: "Optimizer runs. Either a number of 'max'"
  },
  inspect: {
    alias: ["s"],
    describe: writeNestedStructure([
      "Find the generated yul code for a function in the `irOptimized` output.",
      "Setting `ir` will include both the optimized and unoptimized yul outputs.",
      "Note that this can only find functions which still exist in the yul output, and some functions may be inlined or optimized away."
    ]),
    type: "array",
    string: true,
    demandOption: false
  },
  print: {
    alias: ["p"],
    describe: "Print full text of inspected functions, rather than links to generated file.",
    type: "boolean",
    default: false
  }
} as const);

const defaultWriter = new ASTWriter(
  DefaultASTWriterMapping,
  new PrettyFormatter(2),
  LatestCompilerVersion
);

const writeNode = (node: ASTNode) => defaultWriter.write(node);

export const addCommand = <T>(yargs: Argv<T>): Argv<T> =>
  yargs
    .command(
      "ir <input> [output]",
      writeNestedStructure([
        `Compiles a contract and outputs the IR (yul) generated by solc.`,
        `By default, only writes irOptimized and strips out all sourcemap comments and the constructor.`
      ]),
      options,
      async ({ ir: unoptimized, noSourcemap, inspect, print, noConstructor, runs: r, ...args }) => {
        console.log(
          `Include constructor: ${!noConstructor} | Include sourcemap: ${!noSourcemap} | Include ir: ${unoptimized}`
        );
        const runs = r as number | "max";
        // If we are inspecting, we need to include the yul AST in the output
        // for either `irOptimized` or both `irOptimized` and `ir` depending on what the user wants.
        const extraOutputSelection = inspect?.length
          ? [...(unoptimized ? [CompilationOutput.IR_AST] : []), CompilationOutput.IR_OPTIMIZED_AST]
          : [];
        extraOutputSelection.push(
          CompilationOutput.AST,
          ...(unoptimized ? [CompilationOutput.IR] : []),
          CompilationOutput.IR_OPTIMIZED,
          CompilationOutput.EVM_BYTECODE_OBJECT,
          CompilationOutput.EVM_DEPLOYEDBYTECODE_OBJECT
        );
        const { basePath, output, fileName, helper } = await getCommandLineInputPaths(args, false, {
          runs,
          viaIR: true,
          metadata: false,
          optimizer: true,
          debug: {
            debugInfo: ["*"]
          },
          extraOutputSelection
        });

        if (args.output) mkdirIfNotExists(output);
        const contract = helper.getContractForFile(fileName);
        const {
          ir,
          irOptimized,
          irAst,
          irOptimizedAst,
          name /*  functionDebugData, generatedSources, sourceMap */
        } = contract;

        if (!irOptimized) {
          throw Error(
            `Contract ${name} has no intermediate representation - it is likely an interface or abstract contract`
          );
        }
        const files = [[`${name}.optimized.yul`, irOptimized]];
        if (unoptimized) {
          files.push([`${name}.yul`, ir]);
        }
        const inspectFunction = (astJSON: any, name: string, irLabel: string) => {
          const irAst = new ASTReader().convert(astJSON, ModernConfiguration) as YulObject;
          if (name.startsWith("_")) {
            name = name.replace(/^_+/, "");
          }
          const parsedMatches: YulFunctionDefinition[] = [];
          const unparsedMatches: YulFunctionDefinition[] = [];
          irAst.getChildrenByType(YulFunctionDefinition).forEach((fn) => {
            const { originalName } = parseYulIdentifier(fn.name);
            if (originalName?.includes(name)) {
              parsedMatches.push(fn);
            } else if (fn.name.includes(name)) {
              unparsedMatches.push(fn);
            }
          });
          if (parsedMatches.length === 0 && unparsedMatches.length === 0) {
            console.log(err("=".repeat(80)));
            console.log(err(`Could not find yul function ${name} in ${irLabel}`));
            console.log(err("=".repeat(80)));
            return;
          }
          const matches = parsedMatches.length ? parsedMatches : unparsedMatches;

          if (matches.length > 1) {
            console.log(warn("=".repeat(80)));
            console.log(warn(`Found multiple yul functions for ${name} in ${irLabel}`));
            console.log(warn("=".repeat(80)));
          } else {
            console.log(info("=".repeat(80)));
            console.log(info("Found yul function " + matches[0].name + ` in ${irLabel}`));
            console.log(info("=".repeat(80)));
          }
          for (const fn of matches) {
            console.log((success("-") + info("-")).repeat(40));

            console.log(highlightYul(writeNode(fn)));
          }
        };
        if (inspect) {
          for (const fn of inspect) {
            if (unoptimized) {
              inspectFunction(irAst, fn, "ir");
            }
            inspectFunction(irOptimizedAst, fn, "irOptimized");
          }
        }
        if (args.output) {
          for (const [irFileName, irOutput] of files) {
            const data = cleanIR(irOutput, noConstructor, noSourcemap);
            const filePath = path.join(output, irFileName);
            writeFileSync(filePath, data);
          }
        }
        // printCodeSize(helper, fileName);
      }
    )
    .example(
      `$0 ir ./src/ERC20.sol --inspect transfer approve`,
      `Inspect the transfer and approve functions in the optimized yul generated by solc for src/ERC20.sol`
    );
