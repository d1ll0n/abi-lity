import { writeFileSync } from "fs";
import path from "path";
import { Argv } from "yargs";
import { cleanIR, findExternalYulFunction, findYulFunction } from "../../../codegen/utils";
import {
  CompileHelper,
  coerceArray,
  getRelativePath,
  isExternalFunction,
  mkdirIfNotExists,
  writeNestedStructure
} from "../../../utils";
import { getCommandLineInputPaths, printCodeSize } from "../../utils";
import {
  ASTSearch,
  ContractDefinition,
  FunctionDefinition,
  LatestCompilerVersion,
  SourceUnit
} from "solc-typed-ast";
import { astDefinitionToTypeNode } from "../../../readers";
import { info, success, warn } from "../../../test_utils/logs";

const options = {
  input: {
    alias: ["i"],
    describe: "Input Solidity file.",
    demandOption: true,
    coerce: path.resolve
  },
  output: {
    alias: ["o"],
    describe: "Output directory, defaults to directory of input.",
    demandOption: false,
    coerce: path.resolve
  },
  unoptimized: {
    alias: ["u"],
    describe: "Only generate unoptimized IR.",
    default: false,
    type: "boolean"
  },
  verbose: {
    alias: ["v"],
    describe: "Output the entire generated IR, including the constructor and sourcemap comments.",
    default: false,
    type: "boolean"
  },
  runs: {
    alias: ["r"],
    default: 200,
    describe: "Optimizer runs. Either a number of 'max'"
  },
  inspect: {
    alias: ["s"],
    describe: "Find position of specific function(s) in generated yul file.",
    type: "array",
    demandOption: false
  },
  print: {
    alias: ["p"],
    describe: "Print full text of inspected functions, rather than links to generated file.",
    type: "boolean",
    default: false
  }
} as const;

class IrInspector {
  public functions: FunctionDefinition[];
  constructor(
    public yulFilePath: string,
    public link: boolean,
    public functionsToInspect: string,
    public sourceUnit: SourceUnit,
    public helper: CompileHelper
  ) {
    this.functions = ASTSearch.from(sourceUnit).find("FunctionDefinition");
  }

  /*   findFunction(name: string): FunctionDefinition | undefined {
    const candidates = this.functions.filter((f) => f.name === name);
    const external = candidates.find(isExternalFunction);
    if (external) {
      return external;
    }
    if (candidates.length > 0) {
      const internal = candidates.find((f) => !isExternalFunction(f));
      
    }
  } */
}

export const addCommand = <T>(yargs: Argv<T>): Argv<T> =>
  yargs
    .command(
      "ir <input> [output]",
      writeNestedStructure([
        `Compiles a contract and outputs the IR (yul) generated by solc.`,
        `By default, only writes irOptimized and strips out all sourcemap comments and the constructor.`
      ]),
      options,
      async ({ unoptimized, verbose, inspect, print, runs: r, ...args }) => {
        const runs = r as number | "max";
        const link = !print;

        const { basePath, output, fileName, helper } = await getCommandLineInputPaths(
          args,
          false,
          true,
          {
            optimizer: true,
            runs
          }
        );

        mkdirIfNotExists(output);
        const contract = helper.getContractForFile(fileName);
        const { ir, irOptimized, name /*  functionDebugData, generatedSources, sourceMap */ } =
          contract;

        if (!irOptimized) {
          throw Error(
            `Contract ${name} has no intermediate representation - it is likely an interface or abstract contract`
          );
        }
        const files = [[`${name}.optimized.yul`, irOptimized]];
        if (unoptimized) {
          files.push([`${name}.yul`, ir]);
        }
        if (inspect) {
          let code = unoptimized ? ir : irOptimized;
          if (!verbose) {
            code = cleanIR(code);
          }
          const contractDefinition = helper
            .getSourceUnit(fileName)
            .getChildrenByType(ContractDefinition)[0];
          const functions = ASTSearch.fromContract(contractDefinition)
            .find("FunctionDefinition")
            .filter((x) => isExternalFunction(x))
            .map((s) => astDefinitionToTypeNode(s));
          const functionsToInspect = coerceArray(inspect) as string[];
          for (let nameOrSelector of functionsToInspect) {
            if (typeof nameOrSelector === "number") {
              nameOrSelector = "0x" + (nameOrSelector as number).toString(16).padStart(8, "0");
            }
            let result: string | undefined;
            if (nameOrSelector.startsWith("0x")) {
              result = findExternalYulFunction(code, nameOrSelector, link);
            } else {
              const fn = functions.find((f) => f.name === nameOrSelector);
              if (fn) {
                // console.log(
                //   `Function ${nameOrSelector} is external, using selector ${fn.functionSelector}`
                // );
                result = findExternalYulFunction(code, fn.functionSelector, link);
              } else {
                result = findYulFunction(code, nameOrSelector, link);
              }
            }
            if (result) {
              if (link) {
                result = info(
                  `${getRelativePath(
                    process.cwd(),
                    path.join(output, unoptimized ? files[1][0] : files[0][0])
                  )}:${result}`
                );
              }
              console.log(success(`Found yul function ${nameOrSelector} in ${name}:\n`) + result);
            } else {
              console.log(warn(`Could not find yul function ${nameOrSelector} in ${name}`));
            }
          }
        }
        for (const [irFileName, irOutput] of files) {
          const data = verbose ? irOutput : cleanIR(irOutput);
          const filePath = path.join(output, irFileName);
          writeFileSync(filePath, data);
        }
        printCodeSize(helper, fileName);
      }
    )
    .example(
      `$0 ir ./src/ERC20.sol --inspect transfer approve`,
      `Inspect the transfer and approve functions in the optimized yul generated by solc for src/ERC20.sol`
    );
